The !TableModel will take over the work that the template was is doing in the 2.5 release. But instead of being a template that has callbacks (with the exception of the !PageResults) we will store the object that was set and then run everything once the render() method is called.

<img src="http://jmesa.googlecode.com/svn/trunk/jmesa/resources/uml/JMesa3.png" />

The one main difference between The !TableModel and the !TableFacade is that you do not interact with the class. By that I mean you just tell the class what you want, and it executes things in the correct order. This is much different than the !TableFacade in which you would sometimes have a "conversation" with the object to do what you needed.

There are a few things that are left out of the !TableModel. 

 * There is no way to find out if an export is happening or not. But we still need to know that so that the correct table can be created. I think the most straightforward way do this is have a simple static utility method that checks the parameters directly (instead of going through the Limit). 

 * We still want to have a convenient way to save the worksheet. Right now we interact with the !TableFacade to find out if the worksheet is being saved. This is another feature that should be handled with a static utility method that checks the request and session.

 * We want a simple way to get at the Limit.  Right now we interact with the !TableFacade to get the Limit. This is another feature that should be handled with a static utility method that can build the Limit with the factory classes. _The Limit tutorial talks about looking for Limit.isComplete(), and is something the template checks for us. First I will find out why it had to be in the template and not the facade. Then we might consider using the !PageResults callback interface for those using the tag library. I want tag users to not have boilerplate code like checking the complete status._