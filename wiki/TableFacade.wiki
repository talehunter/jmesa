#labels Featured
The !TableFacade takes out the complexity of building Html tables by offering a very high level API to work with.

More examples and documentation can be found here:
 * [FacadeExample Basic Example]
 * [FacadeLimitExample Limit Example]
 * [TagsExample Tags Example]
 * [FacadeGroovyExample Groovy Example]
 * [WorksheetExample Worksheet Example]

The basic idea is you instantiate a !TableFacade class and then interact with it in a natural way. For instance to render an html table all you would have to do is this:

{{{
TableFacade tableFacade = TableFacadeFactory.createTableFacade(id, request);
tableFacade.setColumnProperties("name.firstName", "name.lastName", "term", "career", "born");
tableFacade.setItems(items);
String html = tableFacade.render();
}}}

=== Example ===

The approach that the !TableFacade takes is you declare the whole table with all the defaults, and then customize things as needed. For instance if you want to customize the previous example you can do this (Spring MVC example): 

{{{
protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {
    ModelAndView mv = new ModelAndView(successView);
    Collection<Object> items = presidentService.getPresidents();

    TableFacade tableFacade = TableFacadeFactory.createTableFacade(id, request);
    tableFacade.setColumnProperties("name.firstName", "name.lastName", "term", "career", "born");
    tableFacade.setItems(items);
    tableFacade.setExportTypes(response, ExportType.CSV, ExportType.EXCEL);

    Table table = tableFacade.getTable();
    table.setCaption("Presidents");

    Column firstName = table.getRow().getColumn("name.firstName");
    firstName.setTitle("First Name");

    Column lastName = table.getRow().getColumn("name.lastName");
    lastName.setTitle("Last Name");

    Limit limit = tableFacade.getLimit();
    if (limit.isExported()) {
        facade.render();
        return null;
    } else {
        HtmlTable htmlTable = (HtmlTable) table;
        htmlTable.getTableRenderer().setWidth("600px");

        firstName.getCellRenderer().setCellEditor(new CellEditor() {
            public Object getValue(Object item, String property, int rowcount) {
                Object value = new BasicCellEditor().getValue(item, property, rowcount);
                HtmlBuilder html = new HtmlBuilder();
                html.a().href().quote().append("http://www.whitehouse.gov/history/presidents/").quote().close();
                html.append(value);
                html.aEnd();
                return html.toString();
            }
        });

        String html = tableFacade.render();
        mv.addObject("presidents", html);
    }

    return mv;
}
}}}

_For more information about working with the table, row, and columns read the [Components] section._

Notice how there are no factories to deal with. However any API Object that you need is available through the facade, including the [WebContext], [CoreContext], [Limit], Table, [Toolbar], and [View]. When you ask the facade for a given object it builds everything it needs up to that point. Internally it keeps track of everything you are doing so it also works like a builder. 

The !TableFacade interface also has setters for all the facade objects including the [WebContext], [CoreContext], [Limit], [Toolbar], and [View]. The reason is if you really need to customize something and want to set your own implementation you can. Your object just goes into the flow of the facade. For instance if you want a custom toolbar just set the Toolbar on the facade and when the render() method is called it will use your Toolbar.

However, all this should feel very natural and you should not have to think about what you are doing. Just interact with the facade how you need to and it will take care of everything. *New:* I created a grid that shows the [TableFacadeCallOrder order of the calls] when using the !TableFacadeImpl to help make things clearer.

_Be sure to also check out the [State] feature, which allows a user to come back to a table with it sorted, filtered, and paged the way that they left it. I am so used to this feature that I tend to forgot to mention it, but I bet most people would really enjoy this feature!_

==== !ComponentFactory Option ====
There is now an alternative way to create columns using the API. This technique is completely optional but may be nice in some situations, or you may decide this is a more natural way to create tables.

All you have to do is set the table on the facade. 

{{{
TableFacade tableFacade = TableFacadeFactory.createTableFacade(id, request);
tableFacade.setItems(items);

HtmlComponentFactory factory = new HtmlComponentFactory(tableFacade.getWebContext(), tableFacade.getCoreContext());

HtmlTable table = factory.createTable();

HtmlRow row = factory.createRow();
row.addColumn(factory.createColumn("name.firstName"));
row.addColumn(factory.createColumn("name.lastName"));
row.addColumn(factory.createColumn("term"));

HtmlColumn career = factory.createColumn("career");
career.setFilterable(false);
row.addColumn(career);

table.setRow(row); // be sure to set the row on the table

tableFacade.setTable(table);
}}}

=== Exports ===
Even if you start using the tag library it would still be very handy to use the !TableFacade for the exports. The code would be as easy as this:

{{{
TableFacade tableFacade = TableFacadeFactory.createTableFacade(id, request);
tableFacade.setColumnProperties("name.firstName", "name.lastName", "term", "career");
tableFacade.setItems(items);
tableFacade.setExportTypes(response, ExportType.CSV, ExportType.EXCEL);

Limit limit = tableFacade.getLimit();
if (limit.isExported()) {
    tableFacade.render();
    return null;
}
}}}

All the boilerplate code of rendering the exports is done for you!

_The exports will default to 'table-data.exportType' if no caption is specified._

==== Exports !ComponentFactory Option ====
There is now an alternative way to create columns using the API. This technique is completely optional but may be nice in some situations, or you may decide this is a more natural way to create tables.

All you have to do is set the table on the facade. 

{{{
TableFacade tableFacade = TableFacadeFactory.createTableFacade(id, request);
tableFacade.setItems(items);
tableFacade.setExportTypes(response, ExportType.EXCEL);

Limit limit = tableFacade.getLimit();

if (limit.isExported()) {

    if (limit.getExportType() == ExportType.EXCEL) {
        ExcelComponentFactory factory = new ExcelComponentFactory(tableFacade.getWebContext(), tableFacade.getCoreContext());

        Table table = factory.createTable();

        Row row = factory.createRow();
        row.addColumn(factory.createColumn("name.firstName"));
        row.addColumn(factory.createColumn("name.lastName"));
        row.addColumn(factory.createColumn("term"));
        row.addColumn(factory.createColumn("career"));

        table.setRow(row); // be sure to set the row on the table

        tableFacade.setTable(table);
    }
    
}
}}}