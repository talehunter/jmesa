#labels Featured
I have been reading the Groovy Recipes book recently and I thought it would be a good format for pulling together the JMesa documentation. This will be a work in progress, but the goal is to make this the jumping point to the rest of the wiki. The way this will work is each high level section will be broken down into a question with a brief answer, along with a reference to the rest of the wiki.

== New to JMesa ==

JMesa takes a Collection of beans or a Collection of maps and uses them to render a table in HTML, XLS, CSV, or any other format you choose. The beans in the Collection are plain old Java objects (POJO) where each attribute has a corresponding getter and setter method. If using maps the attributes would be name-value pairs. You can think of each bean as being one row in the table display.

The [Overview overview] will also get you started learning about the [Limit], [CoreContext] and [View].

== Filtering ==

==== How come my table does not filter correctly? ====

By default JMesa will filter your items. The items being the Collection of Beans or Collection of Maps.

However, there is no association between the [Editors CellEditor] and the filtering. That was a design decision for quite a few reasons. For one I wanted a clear detachment between the view and the items. The reason for that is using the API to filter is a feature and for large result sets you have to custom filter anyway. The larger issue is performance. To filter based on the cell editor the API would have to resolve each column and build a separate items object. 

The JMesa filtering mechanism is very flexible and allows you to easily plug in your own [FilterMatcher filter strategy].

==== How do I create a different kind of filter to display on the table? ====

When you interact with the filter on the table you are working with the !FilterEditor interface behind the scenes. The default filter editor is the !HtmlFilterEditor. There is also the newer !DroplistFilterEditor. 

To create your own filter editor you typically extend the !AbstractFilterEditor. This gives you access to !CoreContext, !WebContext and Column. You could also just implement the !FilterEditor directly if you do not need access to any of these.

For more information read the [Editors] page.

== Sorting ==

==== How do I sort the table differently than the default? ====

If you need to sort differently than how it is out of the box you can define your own sorting strategy. Just implement the !ColumnSort and set it on the !TableFacade of the API or tags.

Creating your own sorting strategy is fairly easy. As an example here is the 
[http://code.google.com/p/jmesa/source/browse/tags/jmesa-2.3/src/org/jmesa/core/sort/MultiColumnSort.java default] sorting class.

== View ==

== Toolbar ==

==== How can I place some text in the max rows droplist?  ====

You can place some text next to the max rows increments label (in the droplist). Just specify the text in the [Messages].

{{{
html.toolbar.text.maxRowsDroplist=items 
}}}

== Table ==

 * === Header Row ===

==== How can I change the header on the table to display other things (like a checkbox)? ====

The header row on the table works with the !HeaderEditor interface behind the scenes. The default header editor is the !HtmlHeaderEditor.

To create your own header editor you typically extend the !AbstractHeaderEditor. This gives you access to CoreContext, WebContext and Column. You could also just implement the HeaderEditor directly if you do not need access to any of these.

For more information read the [Editors] page.

==== How do I change the header row to use a th versus a td element? ====

A few developers requested that there be a way to default the html header column element to a <th> versus a <td> definition.

The default is still a <td> element but you can redefine it in the [Preferences] if needed.

{{{
html.column.header.renderer.element=td
}}}

== Exporting ==

== Performance Considerations ==

== Misc ==

==== What do I do if my framework does not give me access to the servlet request and response objects? ====

In my opinion, frameworks that do not offer a way to reach the request and response objects are taking things too far. At a minimum they should offer a way to let other frameworks still get at those objects. What I did was create a servlet filter to set the request and response in a thread local object. 

First setup the filter:
{{{
<filter>
    <filter-name>TableFacadeFilter</filter-name>
    <filter-class>org.jmesa.facade.filter.TableFacadeFilter</
filter-class>
</filter>
<filter-mapping>
    <filter-name>TableFacadeFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping> 
}}}

Then use a static import to get at the request and response:

{{{
import static org.jmesa.facade.filter.TableFacadeFilter.FilterThreadLocal.getHttpServletRequest;
import static org.jmesa.facade.filter.TableFacadeFilter.FilterThreadLocal.getHttpServletResponse;
...

TableFacade tableFacade = TableFacadeFactory.createTableFacade(id, getHttpServletRequest());
tableFacade.setExportTypes(getHttpServletResponse(), CSV, JEXCEL, PDF);
...
}}}

